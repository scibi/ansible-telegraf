---
# .. vim: foldmarker=[[[,]]]:foldmethod=marker

# debops.telegraf default variables [[[
# =====================================

# APT packages, version [[[
# -------------------------

# The ``debops.telegraf`` role uses the ``debops.influxdata`` Ansible role
# to configure the InfluxData APT repositories and install the packages.

# .. envvar:: telegraf__base_packages [[[
#
# List of base APT packages to install.
telegraf__base_packages: [ 'telegraf' ]

                                                                   # ]]]
# .. envvar:: telegraf__packages [[[
#
# List of additional APT packages to install with Elasticsearch.
telegraf__packages: []

                                                                   # ]]]
                                                                   # ]]]

# Configuration for other Ansible roles [[[
# -----------------------------------------

# .. envvar:: telegraf__influxdata__dependent_packages [[[
#
# Configuration for the ``debops.influxdata`` Ansible role.
telegraf__influxdata__dependent_packages:
  - '{{ telegraf__base_packages }}'
  - '{{ telegraf__packages }}'

                                                                   # ]]]
                                                                   # ]]]
                                                                   # ]]]

# FIXME FIXME FIXME FIXME FIXME FIXME
# Opisać poniższe zmienne

telegraf__influxdb_enable: True
telegraf__influxdb_server: "influxdb.{{ ansible_domain }}"
telegraf__influxdb_user: 'telegraf'
telegraf__influxdb_password_path: "{{ secret + '/influxdb/' + ansible_local['influxdb'].delegate_to + '/' + '/credentials/' + telegraf__influxdb_user + '/password' }}"
telegraf__influxdb_password: "{{ lookup('password', telegraf__influxdb_password_path + ' length=20') }}"
telegraf__influxdb_database: 'telegraf'
telegraf__influxdb_skip_verify: False        
telegraf__influxdb_urls: [ "https://{{ telegraf__influxdb_server }}:8086" ]

telegraf__input_plugins: []


telegraf__rabbitmq_installed: '{{ True
                                if (ansible_local|d() and ansible_local.rabbitmq_server|d() and
                                    ansible_local.rabbitmq_server.installed|d() and
                                    ansible_local.rabbitmq_server.installed|bool)
                                else False }}'

telegraf__postfix_installed: '{{ True
                                if (ansible_local|d() and ansible_local.postfix|d() and
                                    ansible_local.postfix.installed|d() and
                                    ansible_local.postfix.installed|bool)
                                else False }}'

telegraf__nginx_enabled: '{{ True
                                if (ansible_local|d() and ansible_local.nginx|d() and
                                    ansible_local.nginx.enabled|d() and
                                    ansible_local.nginx.enabled|bool)
                                else False }}'
telegraf__redis_installed: '{{ True
                                if (ansible_local|d() and ansible_local.redis|d() and
                                    ansible_local.redis.installed|d() and
                                    ansible_local.redis.installed|bool)
                                else False }}'
telegraf__redis_password: '{{ ansible_local.redis.password
                                if (ansible_local|d() and ansible_local.redis|d() and
                                        ansible_local.redis.password|d())
                                else "" }}'

telegraf__ntp_configured: '{{ True
                                if (ansible_local|d() and ansible_local.ntp|d() and
                                    ansible_local.ntp.configured|d() and
                                    ansible_local.ntp.configured|bool)
                                else False }}'

# MQTT Consumer
telegraf__mqtt_consumer_configured: False
telegraf__mqtt_consumer_url: "localhost:1883"
telegraf__mqtt_consumer_qos: "0"
telegraf__mqtt_consumer_topic: "default/#"
telegraf__mqtt_consumer_id: "{{ inventory_hostname_short }}"
telegraf__mqtt_consumer_ca: "/etc/telegraf/ca.pem"

# logparser variables
telegraf__logparser_enabled: False
telegraf__logparser_files: [ "/var/log/nginx/welcome_access.log" ]
telegraf__logparser_read_from_beginning: false
telegraf__logparser_watch_method: "inotify"
telegraf__logparser_patterns: [ "%{COMMON_LOG_FORMAT}" ]
telegraf__logparser_measurement_name: "nginx_access_log"
telegraf__logparser_pattern_files: []
telegraf__logparser_timezone: "Local"

telegraf__default_inputs:
  - name: 'rabbitmq'
    present: '{{ telegraf__rabbitmq_installed}}'
    configuration: |
      ## Management Plugin url. (default: http://localhost:15672)
      # url = "http://localhost:15672"
      ## Tag added to rabbitmq_overview series; deprecated: use tags
      # name = "rmq-server-1"
      ## Credentials
      # username = "guest"
      # password = "guest"
    
      ## Optional SSL Config
      # ssl_ca = "/etc/telegraf/ca.pem"
      # ssl_cert = "/etc/telegraf/cert.pem"
      # ssl_key = "/etc/telegraf/key.pem"
      ## Use SSL but skip chain & host verification
      # insecure_skip_verify = false
    
      ## Optional request timeouts
      ##
      ## ResponseHeaderTimeout, if non-zero, specifies the amount of time to wait
      ## for a server's response headers after fully writing the request.
      # header_timeout = "3s"
      ##
      ## client_timeout specifies a time limit for requests made by this client.
      ## Includes connection time, any redirects, and reading the response body.
      # client_timeout = "4s"
    
      ## A list of nodes to gather as the rabbitmq_node measurement. If not
      ## specified, metrics for all nodes are gathered.
      # nodes = ["rabbit@node1", "rabbit@node2"]
    
      ## A list of queues to gather as the rabbitmq_queue measurement. If not
      ## specified, metrics for all queues are gathered.
      # queues = ["telegraf"]
  - name: 'postfix'
    present: '{{ telegraf__postfix_installed }}'
    configuration: |
      ## Postfix queue directory. If not provided, telegraf will try to use
      #  ## 'postconf -h queue_directory' to determine it.
      #    # queue_directory = "/var/spool/postfix"
  - name: 'nginx'
    present: '{{ telegraf__nginx_enabled }}'
    configuration: |
      # An array of Nginx stub_status URI to gather stats.
      urls = ["http://localhost/nginx_status"]
  - name: 'redis'
    present: '{{ telegraf__redis_installed }}'
    configuration: |
      ## specify servers via a url matching:
      ##  [protocol://][:password]@address[:port]
      ##  e.g.
      ##    tcp://localhost:6379
      ##    tcp://:password@192.168.99.100
      ##
      ## If no servers are specified, then localhost is used as the host.
      ## If no port is specified, 6379 is used
      servers = ["tcp://:{{ telegraf__redis_password }}@localhost:6379"]
  - name: 'ntpq'
    present: '{{ telegraf__ntp_configured }}'
    configuration: |
      ## If false, set the -n ntpq flag. Can reduce metric gather times.
      dns_lookup = true
  - name: 'mqtt_consumer'
    present: '{{ telegraf__mqtt_consumer_configured }}'
    configuration: |
      ## MQTT broker URLs to be used. The format should be scheme://host:port,
      ## schema can be tcp, ssl, or ws.
      servers = ["{{ telegraf__mqtt_consumer_url }}"]
      ## MQTT QoS, must be 0, 1, or 2
      qos = {{ telegraf__mqtt_consumer_qos }}

      ## Connection timeout for initial connection in seconds
      connection_timeout = "30s"

      ## Topics to subscribe to
      topics = [
        "{{ telegraf__mqtt_consumer_topic }}"
      ]

      # if true, messages that can't be delivered while the subscriber is offline
      # will be delivered when it comes back (such as on service restart).
      # NOTE: if true, client_id MUST be set
      persistent_session = true
      # If empty, a random client ID will be generated.
      client_id = "{{ telegraf__mqtt_consumer_id }}"

      ## username and password to connect MQTT server.
      # username = "telegraf"
      # password = "metricsmetricsmetricsmetrics"

      ## Optional SSL Config
      ssl_ca = "{{ telegraf__mqtt_consumer_ca }}"
      # ssl_cert = "/etc/telegraf/cert.pem"
      # ssl_key = "/etc/telegraf/key.pem"
      ## Use SSL but skip chain & host verification
      # insecure_skip_verify = false

      ## Data format to consume.
      ## Each data format has its own unique set of configuration options, read
      ## more about them here:
      ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
      data_format = "influx"
  - name: 'logparser'
    present: '{{ telegraf__logparser_enabled }}'
    configuration: |
      ## Log files to parse.
      ## These accept standard unix glob matching rules, but with the addition of
      ## ** as a "super asterisk". ie:
      ##   /var/log/**.log     -> recursively find all .log files in /var/log
      ##   /var/log/*/*.log    -> find all .log files with a parent dir in /var/log
      ##   /var/log/apache.log -> only tail the apache log file
      files = [ {% for item in telegraf__logparser_files %} {% if loop.index > 1 %},{% endif %} "{{ item }}" {% endfor %} ]

      ## Read files that currently exist from the beginning. Files that are created
      ## while telegraf is running (and that match the "files" globs) will always
      ## be read from the beginning.
      from_beginning = {{ telegraf__logparser_read_from_beginning | lower }}

      ## Method used to watch for file updates.  Can be either "inotify" or "poll".
      watch_method = "{{ telegraf__logparser_watch_method }}"
      ## Parse logstash-style "grok" patterns:
      ##   Telegraf built-in parsing patterns: https://goo.gl/dkay10
      [inputs.logparser.grok]
        ## This is a list of patterns to check the given log file(s) for.
        ## Note that adding patterns here increases processing time. The most
        ## efficient configuration is to have one pattern per logparser.
        ## Other common built-in patterns are:
        ##   %{COMMON_LOG_FORMAT}   (plain apache & nginx access logs)
        ##   %{COMBINED_LOG_FORMAT} (access logs + referrer & agent)
        pattern = [ {% for item in telegraf__logparser_patterns %} {% if loop.index > 1 %},{% endif %} "{{ item }}" {% endfor %} ]

        ## Name of the outputted measurement name.
        measurement = "{{ telegraf__logparser_measurement_name }}"

        ## Full path(s) to custom pattern files.
        #custom_pattern_files = []
        custom_pattern_files = {{ telegraf__logparser_pattern_files }}

        ## Custom patterns can also be defined here. Put one pattern per line.
        #custom_patterns = '''
        #'''

        ## Timezone allows you to provide an override for timestamps that
        ## don't already include an offset
        ## e.g. 04/06/2016 12:41:45 data one two 5.43µs
        ##
        ## Default: "" which renders UTC
        ## Options are as follows:
        ##   1. Local             -- interpret based on machine localtime
        ##   2. "Canada/Eastern"  -- Unix TZ values like those found in https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
        ##   3. UTC               -- or blank/unspecified, will return timestamp in UTC
        timezone = "{{ telegraf__logparser_timezone }}"
 


# support MQTT output

telegraf__output_mqtt: False
telegraf__mqtt_servers: 
    - host: "127.0.0.1"
      port: "1883"
    - host: "127.0.0.2"
      port: "8883"

telegraf__mqtt_topic_prefix: "default_topic_prefix"
telegraf__mqtt_data_format: "influx"




